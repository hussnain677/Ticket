import React from 'react';
import Animated from 'react-native-reanimated';
import { TapGestureHandler, PanGestureHandler, State as GestureState } from 'react-native-gesture-handler';
import { View, StyleSheet } from 'react-native';
import { SrcInComposition, SweepGradient, ImagePlaceholder, RadialGradient } from 'react-native-image-filter-kit';
import { HueSaturationWheel } from './HueSaturationWheel';
const { call, cond, eq, and, or, set } = Animated;
const colors = [
    '#FF0000',
    '#FFFF00',
    '#00FF00',
    '#00FFFF',
    '#0000FF',
    '#FF00FF',
    '#FF0000'
];
const stops = [0, 0.165, 0.33, 0.495, 0.66, 0.825, 1];
const radialColors = ['#00000000', '#000000FF'];
export const Wheel = React.memo((props) => {
    const { side, thumbSize, translateX, translateY, thumbColor, wheelOpacity, panGestureEvent, onColorChange, onColorChangeComplete, codeKey, gestureState, startX, startY, valueGestureState, hue, saturation, value } = props;
    const thumbOffset = -thumbSize / 2;
    const imageSide = side - thumbSize;
    const containerStyle = { width: side, height: side };
    const imageStyle = {
        width: imageSide,
        height: imageSide,
        borderRadius: imageSide / 2
    };
    const thumbStyle = {
        width: thumbSize,
        height: thumbSize,
        borderRadius: thumbSize / 2
    };
    return (<TapGestureHandler onHandlerStateChange={panGestureEvent}>
      <Animated.View style={[styles.container, containerStyle]}>
        <PanGestureHandler maxPointers={1} onGestureEvent={panGestureEvent} onHandlerStateChange={panGestureEvent}>
          <Animated.View style={[styles.container, containerStyle]}>
            <View style={[styles.wheel, imageStyle]}>
              <SrcInComposition srcImage={<SweepGradient colors={colors} stops={stops} image={<ImagePlaceholder style={imageStyle}/>}/>} dstImage={<RadialGradient colors={radialColors} image={<ImagePlaceholder style={imageStyle}/>}/>}/>
              <Animated.View style={[
            imageStyle,
            styles.wheelOverlay,
            { opacity: wheelOpacity }
        ]}/>
              <Animated.View style={[
            styles.thumb,
            thumbStyle,
            // @ts-expect-error
            {
                backgroundColor: thumbColor,
                transform: [
                    { translateX },
                    { translateY },
                    { translateX: thumbOffset },
                    { translateY: thumbOffset }
                ]
            }
        ]}/>
              {onColorChangeComplete !== undefined ? (<Animated.Code key={`change_complete_${codeKey}`} exec={cond(and(or(eq(gestureState, GestureState.END), eq(gestureState, GestureState.UNDETERMINED)), or(eq(valueGestureState, GestureState.END), eq(valueGestureState, GestureState.UNDETERMINED)), or(HueSaturationWheel.isGestureStartedInsideCircle(gestureState, startX, startY, thumbSize, side), eq(valueGestureState, GestureState.END))), [
                set(valueGestureState, GestureState.UNDETERMINED),
                call([hue, saturation, value], onColorChangeComplete)
            ])}/>) : (false)}
              {onColorChange !== undefined ? (<Animated.Code key={`change_${codeKey}`} exec={cond(or(HueSaturationWheel.isGestureStartedInsideCircle(gestureState, startX, startY, thumbSize, side), eq(valueGestureState, GestureState.BEGAN), eq(valueGestureState, GestureState.ACTIVE)), call([hue, saturation, value], onColorChange))}/>) : (false)}
            </View>
          </Animated.View>
        </PanGestureHandler>
      </Animated.View>
    </TapGestureHandler>);
});
const styles = StyleSheet.create({
    container: {
        justifyContent: 'center',
        alignItems: 'center'
    },
    wheel: {
        width: '100%',
        height: '100%',
        backgroundColor: 'white'
    },
    wheelOverlay: {
        position: 'absolute',
        backgroundColor: 'black'
    },
    thumb: {
        position: 'absolute',
        borderColor: 'white',
        borderWidth: 2
    }
});
//# sourceMappingURL=Wheel.js.map